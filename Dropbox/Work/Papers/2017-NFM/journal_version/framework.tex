\section{Compositional Falsification Framework}
\label{sec:framework}

In this section, we formalize the falsification problem for STL specifications against CPSML models,
define our compositional falsification framework, and show its functionality on the AEBS system of
Example~\ref{ex:aebs}.

%\fixme{edit this section to clarify the interface between the
%CPS falsifier and the ML analyzer, also the optimistic/pessimistic
%analyses}

%\subsection{Falsification Problem}
%\label{sec:fals_prob}

\begin{definition}[Falsification of CPSML]
Given a model $M = (\stsp,\insp,\simu)$ and an STL specification $\varphi$,
find an initial state $\vx(t_0) \in \stsp$ and a sequence of input values
$\vu = \vu(t_0), \dots, \vu(t_n) \in \insp$ such that the trace of states
$w = \vx(t_0),\dots, \vx(t_n)$
generated by the simulation of $M$ from $\vx(t_0) \in \stsp$
under $\vu$ does not satisfy $\varphi$,
i.e., $w \not\models \varphi$.
We refer to such $(\vx(t_0),\vu)$ as \emph{counterexamples} for $\varphi$.
The problem of finding a counterexample is often called
the \emph{falsification problem}.
\label{defn:fals_prob}
\end{definition}

We now present the compositional framework for the falsification of STL formulas against CPSML models.
Intuitively, the proposed method decomposes a given model into two abstractions: a version of the CPSML model
under the assumption of perfectly correct ML modules and its actual ML components. The two abstractions
are separately analyzed, the first by a temporal logic falsifier that builds the validity domain with respect to the given specification,
the second by an ML analyzer that identifies sets of feature vectors that are misclassified by the ML components.
Finally, the results of the two analysis are composed and projected back to a targeted input subspace of the original CPSML model
where  counterexamples can be found by invoking a temporal logic falsifier.
Let us formalize this procedure.

Let $M = (\stsp,\insp,\simu)$ be a CPSML model and $\varphi$ be an STL specification.
Consider creating an ``optimistic'' abstraction $M^+$ of $M$:
in other words, $M^+$ is a version of $M$ with perfect ML components, 
that is,
every feature vector of the ML feature space is correctly classified. Let us denote
by $ml$ the isolated ML components of the model $M$.

Under the assumption of correct ML components, the lower-dimensional input space
of $M^+$ can be analyzed by constructing the validity domain of $\varphi$, that is 
the partition of the input space into the sets $U_\varphi$ and $U_{\neg\varphi}$
that do and do not satisfy $\varphi$, respectively.
Note that considering the original model $M$, a possible misclassification of the ML components $ml$ might affect
the elements of $U_\varphi$ and $U_{\neg\varphi}$. In particular, we
are interested in the elements of $U_\varphi$ that, due to misclassifications of $ml$, do not satisfy $\varphi$ anymore.
This corresponds to analyzing the behavior of the ML components $ml$ on the input set $U_\varphi$.
We refer to this step as the ML analysis. It can be seen as a procedure
for finding a subset $U^{ml} \subseteq U_\varphi$ of input values
that are misclassified by the ML components $ml$.
It is important to note that the input space 
of the CPS model $M^+$ and the feature spaces of the ML modules $ml$ are 
different; thus, the ML analyzer must adapt and relate the two 
different spaces. This important step will be clarified in
Section~\ref{sec:MLanalysis}.

Finally, the intersection $U_\varphi \cap U^{ml}$  of the subsets identified by the decomposed 
analysis of the CPS model and its ML components targets a small set of input values that 
are misclassified by the ML modules and are likely to falsify $\varphi$.
Thus, counterexamples in $U_\varphi \cap U^{ml} \subseteq U$ can be determined
by invoking a temporal logic falsifier on $\varphi$ against $M$.

As explained below, we can pair the ``optimistic'' abstraction explained above 
with a ``pessimistic'' abstraction as well, so as to obtain
a further restriction of the input space.

\begin{algorithm}
	\caption{CPSML falsification scheme (one iteration between CPS Analyzer and ML Analyzer)}
  \label{algo:CPSMLfalsification}
  \begin{algorithmic}[1]
    	\Function{CompFalsfy}{$M, \varphi$}\Comment{$M$ CPSML, $\varphi$ STL specification}
	\State $[M^+,ml] \gets$\Call{Decompose}{$M$}\label{ln:decompose_pos}\Comment{$M^+$ -- perfect ML, $ml$ -- ML component}
	\State $[U_\varphi^+, U_{\neg\varphi}^+] \gets$\Call{ValidityDomain}{$M^+,U,\varphi$}\label{ln:valdom_pos}\Comment{Validity domain of $\varphi$ w.r.t. $M^+$}
	\State $[M^-,ml] \gets$\Call{Decompose}{$M$}\label{ln:decompose_neg}\Comment{$M^-$ -- wrong ML, $ml$ -- ML component}
	\State $[U_\varphi^-, U_{\neg\varphi}^-] \gets$\Call{ValidityDomain}{$M^-,U,\varphi$}\label{ln:valdom_neg}\Comment{Validity domain of $\varphi$ w.r.t. $M^-$}
	  \State $U_{rou} \gets U_\varphi^+ \setminus U_\varphi^-$  \label{ln:ROU} \Comment{Compute ROU}
	  \State $U^{ml} \gets$ \Call{MLAnalysis}{$ml,U_{rou}$}\label{ln:mlanalysis}\Comment{Find misclassified feature vectors in ROU}
	\State $U^{ml}_{\neg\varphi} \gets $\Call{Falsify}{$M,U_\varphi \cap U^{ml},\varphi$}\label{ln:fals}\Comment{Falsify on targeted input}
	\State \Return $U_{\neg\varphi} \cup U^{ml}_{\neg\varphi}$
	%\State $[M',ml] \gets$\Call{Decompose}{$M$}\label{ln:decompose}\Comment{$M'$ perfect ML, $ml$ ML modules}
	%\State $[U_\varphi, U_{\neg\varphi}] \gets$\Call{ValidityDomain}{$M',U,\varphi$}\label{ln:valdom}\Comment{Validity domain of $\varphi$ w.r.t. $M'$}
	%\State $U^{ml} \gets$ \Call{MLAnalysis}{$ml,U_\varphi$}\label{ln:mlanalysis}\Comment{Find misclassified feature vectors}
	%\State $U^{ml}_{\neg\varphi} \gets $\Call{Falsify}{$M,U_\varphi \cap U^{ml},\varphi$}\label{ln:fals}\Comment{Falsify on targeted input}
	%\State \Return $U_{\neg\varphi} \cup U^{ml}_{\neg\varphi}$
      \EndFunction
  \end{algorithmic} 
\end{algorithm}

The compositional falsification procedure is formalized in Algorithm~\ref{algo:CPSMLfalsification}.
\Call{CompFalsfy}{} receives as input a CPSML model $M$ and 
an STL specification $\varphi$, and returns a set of falsifying counterexamples.
At first, the algorithm decomposes $M$ into $M^+$ and $ml$, where $M^+$ is an abstract version of $M$ with ML components $ml$ that return perfect answers (classifications) (Line~\ref{ln:decompose_pos}).
Then, the validity domain of $\varphi$ with respect to the abstraction $M^+$ is computed 
by \Call{ValidityDomain}{} (Line~\ref{ln:valdom_pos}).
Next, the algorithm computes $M^-$ and $ml$ from $M$, where $M^-$ is an abstract version of $M$ with ML components $ml$ that always return wrong answers (misclassifications) (Line~\ref{ln:decompose_neg}).
Note that this step can be combined with Line~\ref{ln:decompose_pos},
but we leave it separate for clarity in the abstract algorithm specification.
Then, the validity domain of $\varphi$ with respect to the abstraction $M^-$ is computed 
by \Call{ValidityDomain}{} (Line~\ref{ln:valdom_neg}).
The region of uncertainty (ROU), where misclassifications of the
ML components can lead to violations of $\varphi$,
is then computed as $U_{rou}$ (Line~\ref{ln:ROU}).
From this, the subset of inputs that are misclassified by 
$ml$ is identified by \Call{MLAnalysis}{} (Line~\ref{ln:mlanalysis}).
Finally, the targeted input set $U_\varphi \cap U^{ml}$,
consisting in the intersection of the sets identified by the decomposed 
analysis, is searched by a temporal logic falsifier on the original model $M$ (Line~\ref{ln:fals})
and the set of inputs that falsify the temporal logic formula
are returned.

Note that the above approach can be implemented even without 
computing $M^-$ (Lines~\ref{ln:decompose_neg}-\ref{ln:ROU}), 
in which case the entire validity domain of $\varphi$ is considered
as the ROU. For simplicity, we will take this truncated approach
in the example described below. In Section~\ref{sec:experiments},
we will describe results on the AEBS case study with the full approach.

%%%%%%%%%%%
\comment{
The compositional falsification procedure is formalized in Algorithm~\ref{algo:CPSMLfalsification}.
\Call{CompFalsfy}{} receives as input a CPSML model $M$ and 
an STL specification $\varphi$, and returns a set of falsifying counterexamples.
At first, the algorithm decomposes $M$ into $M'$ and $ml$, where $M'$ is an abstract version of $M$ with perfectly
working ML modules, and $ml$ are the ML components of $M$ (Line~\ref{ln:decompose}).
Then, the validity domain of $\varphi$ with respect to the abstraction $M'$ is computed 
by \Call{ValidityDomain}{} (Line~\ref{ln:valdom}) and subsets of input that are misclassified by 
$ml$ are identified by \Call{MLAnalysis}{} (Line~\ref{ln:mlanalysis}).
Finally, the targeted input set $U_\varphi \cap U^{ml}$,
consisting in the intersection of the sets identified by the decomposed 
analysis, is searched by a temporal logic falsifier on the original model $M$ (Line~\ref{ln:fals})
and the set of inputs that falsify the temporal logic formula
are returned.
%and a collection of counterexamples is returned.
} % end comment
%%%%%%%%%%%%

\begin{figure}
  	\begin{center}
    		\includegraphics[width=0.5\textwidth]{./pics/comp_ex.png}
	 \end{center}
  	\caption{Compositional falsification scheme on AEBS model. The ``score'' indicates the confidence level with which the classifier determines whether the image contains a car or not.\label{fig:comp_ex}}
\end{figure}

\begin{example}
Let us consider the model described in Example~\ref{ex:aebs}
and let us assume that the input space $U$ of the model $M$ consists of the
initial velocity of the subject vehicle $vel(0)$, the initial
distance between the vehicle and the preciding obstacle $dist(0)$,
and the set of pictures that can be captured by the camera.
Let $\varphi := \G{[0,T]}(dist(t) \geq \tau)$ be a specification that 
requires the vehicle to be always 
farther than $\tau$ from the preceding obstacle.
Instead of analyzing the whole input space $U$ (including a vast number of pictures),
we can adopt our compositional framework to target a 
specific subset of $U$. 
Let $M^+$ be the AEBS model with a perfectly working image classifier
and $ml$ be the actual classifier. We begin by computing the
validity subsets $U_{\varphi}$ and $U_{\neg\varphi}$ of $\varphi$ against $M^+$, considering only $vel(0)$
and $dist(0)$ and assuming exact distance measurements during the
simulation. Next, we analyze only the image classifier $ml$
on pictures of obstacles whose distances fall in $U_{\varphi}$, say in $[d_m,d_M]$ (see Figure~\ref{fig:comp_ex}).
Our ML analyzer generates only pictures of obstacles whose distances are in
$[d_m,d_M]$, finds possible sets of images that are misclassified, and
returns the corresponding distances that, when projected back to $U$,
yield the subset $U_{\varphi} \cap U^{ml}$.
Finally, a temporal logic falsifier can be invoked over
$U_{\varphi} \cap U^{ml}$ and a set of counterexamples is returned.


%\begin{figure}
%	\centering
%	\includegraphics[scale=0.22]{./pics/framework_scheme.png}
%	\caption{Cooperative falsification scheme. Closed-loop control system (left), specification satisfaction map with exact measurements (top-right),
%			and machine learning analysis (bottom-right). 1) The exact safe region is projected into the ML input space 2) Misclassifications are 
%			identified and 3) Projected back to the system input space.\label{fig:coo_scheme}}
%\end{figure}
\end{example}

Algorithm~\ref{algo:CPSMLfalsification} and the above example 
show how our compositional approach relies on three key
steps:
(i) computing the validity domain for an STL formula for
a given simulation model;
(ii) falsifying an STL formula on a simulation model,
and 
(iii) a ML analyzer that computes a sub-space of its input
feature space that lead to misclassifications.
The first two steps have been well-studied in the literature
on simulation-based verification of CPS, and implemented in
tools such as Breach~\cite{donze2010breach}. 
We discuss our approach to Step (iii) in the next section
--- our ML analyzer
that identifies misclassifications of the ML component
relevant to the overall CPSML input space.





